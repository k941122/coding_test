/**
 * 가장 가까운 같은 글자
 * 
 * 문제 설명
 * 
 * 문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.
 * 예를 들어, s="banana"라고 할 때,  각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.
 *
 * b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
 * a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
 * n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
 * a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.
 * n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.
 * a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.
 * 따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.
 * 
 * 문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.
 * 
 * 제한 사항
 * 
 * - 1 ≤ s의 길이 ≤ 10,000
 *   s은 영어 소문자로만 이루어져 있습니다.
 * 
 * 입출력 예시
 * 
 * s	result
 * "banana"	[-1, -1, -1, 2, 2, 2]
 * "foobar"	[-1, -1, 1, -1, -1, -1]
 * 
 * 입출력 예시 설명
 * 
 * ex1) 지문과 같습니다.
 * 
 * ex2) 설명 생략
 * 
 */

/**
 * 문제 해석
 * 
 * 처음 나온 알파벳 -1
 * 
 * 문자형에서 자신과 중복되게 나온 숫자 값에서 자신이 몇번째 떨어져 있는지 숫자로 표시
 * 
 * 
 * 
 */

function solution(s) {
    const arr = s.split("");
    return arr.map(v=>s.lastIndexOf(v));
} 

/**
 * lastIndexOf 를 이용해서 중복되지 않으면 -1 중복되면 해당 index 값을 return 하는
 * 기능을 이용하려고 했다.
 * 
 * 하지만 오답이 나왔다. 
 */

function solution(s) {
    const arr = s.split("");
    return arr.map((v,i,arr)=>{
        if(arr.slice(0,i).lastIndexOf(v)+1 == 0){
            return -1
        }else{
            return i-arr.slice(0,i).lastIndexOf(v);
        }
    })
} 

/**
 * 위의 오답코드가 틀린 이유는 해당 문자열의 위치에서 해당 문자가 마지막으로 나타내는
 * index를 return 하는 형식 이었기 때문이었다. 문제에서 요구한 것은 해당 문자가 
 * 자신보다 앞에 나온 곳 중에서 가장 가까운 위치를 찾는 것이다.
 * 
 * 그래서 arr 배열에 map을 이용하여 콜백함수의 매개변수에 v,i,arr을 넣은다음
 * if else문을 이용해서 arr(배열)에서 해당 v가 0(처음 등장)일 경우 -1을 return 해 주었고
 * 
 * 그게 아니라면 현제 인덱스에서 마지막으로 나온 배열의 인덱스를 빼줘서 return 하게 하였다.
 * 
 * 그러면 map 메서드에 해당 if else문이 있기 때문에 배열의 요소가 달라진다.
 */