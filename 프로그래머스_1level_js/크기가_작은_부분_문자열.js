/**
 * 크기가 작은 부분 문자열
 * 
 * 문제 설명
 * 
 * 숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서, 
 * 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 
 * 나오는 횟수를 return하는 함수 solution을 완성하세요.
 * 
 * 예를 들어, t="3141592"이고 p="271" 인 경우, t의 길이가 3인 부분 문자열은 
 * 314, 141, 415, 159, 592입니다. 이 문자열이 나타내는 수 중 271보다 작거나 
 * 같은 수는 141, 159 2개 입니다.
 * 
 * 제한 사항
 * 
 * - 1 ≤ p의 길이 ≤ 18
 * 
 * - p의 길이 ≤ t의 길이 ≤ 10,000
 * 
 * - t와 p는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다.
 * 
 * 입출력 예시
 * 
 *     t	      p	result
 * "3141592"	"271"	2
 * "500220839878"	"7"	8
 * "10203"	"15"	3
 * 
 * 입출력 예시 설명
 * 
 * ex1) 본문과 같습니다.
 * 
 * ex2) p의 길이가 1이므로 t의 부분문자열은 
 *      "5", "0", 0", "2", "2", "0", "8", "3", "9", "8", "7", "8"이며 이중 7보다 
 *      작거나 같은 숫자는 "5", "0", "0", "2", "2", "0", "3", "7" 이렇게 8개가 있습니다.
 * 
 * ex3) p의 길이가 2이므로 t의 부분문자열은 "10", "02", "20", "03"이며, 
 *      이중 15보다 작거나 같은 숫자는 "10", "02", "03" 이렇게 3개입니다. 
 *      "02"와 "03"은 각각 2, 3에 해당한다는 점에 주의하세요
 * 
 */

/**
 * 문제 해석
 * 
 * 숫자로 이루어진 문자열 t p
 * 
 * t를 워본 p를 부분이라고 할때 p의 길이만큼 t를 잘라서 해당 문자열과 p의 크기를 비교해서
 * 작거나 같을때의 숫자 갯수를 카운트 하시오.
 * 
 */

function solution(t, p) {
    const numP = Number(p);
    let answer = 0;

    for(let i =0; i< t.length - p.length +1;i++){
        const subStrT = t.slice(i, i+p.length);
        const numT = Number(subStrT);

        if (numT <= numP){
            answer += 1;
        }
    }
    return answer;
}

/**
 * t 문자형의 부분 문자형 p와 길이를 비교해서 p의 길이 만큼의 t의 부분 문자열이 p와 크기를
 * 비교해서 같거나 작은것을 구해야 된다.
 * 
 * 문자형 p를 Number 메서드를 이용해서 숫자형으로 바꿔준다.
 * 
 * 그리고 answer 변수에 0을 할당해서 for문을 순회할때마다 해당 조건에 일치할때 마다 
 * 숫자를 누적시키게 해준다.
 * 
 * for 반복문의 조건에 t의 길이에 p의 길이를 뺀 값에 1을 더한값 만큼 순회해 준다.
 * 
 * subStrT에 t에 slice 메서드를 이용해서 해당 문자형의 i를 시작으로 지정하고
 *  i와 t의 길이를 더한 값을 더해준 값을 마지막 값으로 원하는 값을 추출해 준다.
 * 
 * numT상수에 Number 메서드를 이용해 위의 subStrT의 값을 숫자형으로 바꿔준다.
 * 
 * 그리고 IF 문을 이용해서 numT의 값이 numP 보다 작거나 같을때 마다 answer에 1을 누적해서
 * 수를 카운트 해준다.
 */