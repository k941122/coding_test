/**
 * 2의 영역
 * 
 * 문제 설명
 * 
 * 정수 배열 arr가 주어집니다. 배열 안의 2가 모두 포함된 
 * 가장 작은 연속된 부분 배열을 return 하는 solution 함수를 완성해 주세요.
 * 
 8 단, arr에 2가 없는 경우 [-1]을 return 합니다.
 * 
 * 제한 사항
 * 
 * - 1 ≤ arr의 길이 ≤ 100,000
 *   1 ≤ arr의 원소 ≤ 10
 * 
 * 입출력 에시
 * 
 *    arr	                        result
 * [1, 2, 1, 4, 5, 2, 9]	    [2, 1, 4, 5, 2]
 * [1, 2, 1]	                [2]
 * [1, 1, 1]	                [-1]
 * [1, 2, 1, 2, 1, 10, 2, 1]	[2, 1, 2, 1, 10, 2]
 * 
 * 입출력 에시 설명
 * 
 * ex1) 2가 있는 인덱스는 1번, 5번 인덱스뿐이므로 1번부터 5번 인덱스까지의 부분 배열인 
 *      [2, 1, 4, 5, 2]를 return 합니다.
 * 
 * ex2) 2가 한 개뿐이므로 [2]를 return 합니다.
 * 
 * ex3) 2가 배열에 없으므로 [-1]을 return 합니다.
 * 
 * ex4) 2가 있는 인덱스는 1번, 3번, 6번 인덱스이므로 1번부터 6번 인덱스까지의 
 *      부분 배열인 [2, 1, 2, 1, 10, 2]를 return 합니다.
 * 
 */

/**
 * 문제 해석
 * 
 * arr 정수배열
 * 
 * 배열의 요소에 2를 포함 하는 부분을 출력
 * 
 * 2가 시작 되는 부분 2로 끝나는 부분 만을 추출해서 출력
 * 
 * 2가 하나면 2만 출력
 * 
 * 2가 없으면 -1 출력
 * 
 * 배열의 2인 index 들을 출력하기. 
 * 
 * reduce ? filter ? map ? index를 새로운 배열에 담자 
 * 
 * if 문 필수 ( i === 2)
 * answer += arr[i]
 */


//▼ 오답 코드
function solution (arr) {
    let answer = [];

    arr.forEach((item,idx) => {
        if (item === 2) {
            answer.push(idx)
        }
    }) 
    const result = arr.slice(answer[0],(answer.length-1)+1);
    return result;
}

/**
 * 테스트 1
 * 입력값 〉	[1, 2, 1, 4, 5, 2, 9] 
 * 기댓값 〉	[2, 1, 4, 5, 2]
 * 실행 결과 〉	실행한 결괏값 [2]이 기댓값 [2,1,4,5,2]과 다릅니다.
 * 테스트 2
 * 입력값 〉	[1, 2, 1]
 * 기댓값 〉	[2]
 * 실행 결과 〉	실행한 결괏값 []이 기댓값 [2]과 다릅니다.
 * 테스트 3
 * 입력값 〉	[1, 1, 1]
 * 기댓값 〉	[-1]
 * 실행 결과 〉	실행한 결괏값 []이 기댓값 [-1]과 다릅니다.
 * 테스트 4
 * 입력값 〉	[1, 2, 1, 2, 1, 10, 2, 1]
 * 기댓값 〉	[2, 1, 2, 1, 10, 2]
 * 실행 결과 〉	실행한 결괏값 [2,1]이 기댓값 [2,1,2,1,10,2]과 다릅니다.
 */


function solution (arr) {
    let answer = [];

    arr.forEach((item,idx) => {
        if (item === 2) {
            answer.push(idx)
        }
    }) 
    const result = arr.slice(answer[0],answer[answer.length-1]+1);
    return result.length !== 0? result:[-1]; 
}

/**
 * 왜  에러가 일어 났는지 찾았다.
 * .slice(answer[0],(answer.length-1)+1) 
 * slice 메서드 사용 부분에서 end index를 작성하는 부분에서
 * answer[인덱스 숫자] 형식으로 입력해야 되는데, (answer.length-1)형식으로 작성했다.
 * 
 * forEach 문을 이용해 arr 배열을 순회하는데 매개 변수로 값과 인덱스를 받아서
 * 
 * if문의 조건 안에 arr 값이 2와 일치한다면 
 * answer(빈배열) 안에 arr의 해당 인덱스 값을 넣게 했다.
 * 
 * 상수 result 안에 arr배열을 slice 메서드를 이용해 원하는 범위 만큼 추출하는데,
 * 
 * start index 부분에 answer 첫번째 요소를(0번째 index), end index 에 answer의 마지막 인덱스를 넣는데
 * 마지막 인덱스는 answer의 길이에 -1을 해준다. 왜냐하면 length는 길이를 측정하기 때문에
 * 1,2,3..순으로 시작하지만 배열은 0,1,2... 순으로 시작하기 때문이다.
 * 마자막으로 answer의 길이에 +1을 해줘야 되는데, slice 메서드는 end index 부분 바로 앞 까지만
 * 추출하기 때문이다.
 * 
 * 해당 result가 비어있다면 [-1을 입력하라고 했기 때문에 삼항 연산자를 통해 
 * rsult가 0이 아니라면 result 배열을 출력하고 0이라면 [-1]을 출력하게 했다. 
 * 
 */