/**
 * 한 번만 등장한 문자
 * 
 * 문제 설명
 * 
 * 문자열 s가 매개변수로 주어집니다. s에서 한 번만 등장하는 
 * 문자를 사전 순으로 정렬한 문자열을 return 하도록 solution 함수를 완성해보세요. 
 * 한 번만 등장하는 문자가 없을 경우 빈 문자열을 return 합니다.
 * 
 * 제한 사항
 * 
 * - 0 < s의 길이 < 1,000
 * - 0 < s의 길이 < 1,000
 * 
 * 입출력 예시
 * 
 *     s	    result
 * "abcabcadc"	"d"
 * "abdc"	    "abcd"
 * "hello"	    "eho"
 * 
 * 압출력 에시 설명
 * 
 * ex1) "abcabcadc"에서 하나만 등장하는 문자는 "d"입니다.
 * ex2) "abdc"에서 모든 문자가 한 번씩 등장하므로 사전 순으로 정렬한 "abcd"를 return 합니다.
 * ex3) "hello"에서 한 번씩 등장한 문자는 "heo"이고 이를 사전 순으로 정렬한 "eho"를 return 합니다.
 * 
 * 
 */

/**
 * 문제 해석
 * 
 * 반복되는 문자형 요소 제거. 중복되는 요소 제거
 * 
 * filter 삼항연산자 이용.
 * 
 * 삼항 연산자의 조건 ? indcludes? 이용? 문자형 메서드 중에서 일치하는 문자형 찾아주는 메서드 
 * -> 
 * 
 */

// ▼ 오답 코드
function solution (s) {
    return [...s].filter((v,i)=> [...s].indexOf(v) === i?v:"" ).sort().join("")
}

/**
 * filter 메서드의 callback 식에 indexOf를 쓰고 메서드로 v(값)을 넣은후 
 * index와 일치 여부를 물어 보는 식을 입력했다. 
 * 
 * 그리고 난뒤 이 식과 일치하면 삼항 연산자를 통해 true면 값을 반환하고 아니면 공백을
 * 반환 하게 했다.
 * 
 * 하지만 테스트 1,3번이 오답으로 처리 됬고 결과를 보니
 * 중복된 요소 둘다를  제거 한게 아닌, 중복된 문자열 둘중 하나만을 남겨놓은 상태였다.
 */

// ▼ 정답 코드
function solution (s) {
    return [...s].filter((v,i)=> [...s].indexOf(v) === [...s].lastIndexOf(v)?v:"" ).sort().join("")
}

/**
 * 위의 오답 코드에서, indexOf(v)와 i가 일치 하는 것에 대한 여부를
 * indexOf(v) 와 lastIndexOf(v)가 일치하는지 여부를 확인 하는 것으로 바꿨다.
 * 
 * 중복된 요소가 아니라면 한번만 나오기 때문에 첫번째 인덱스와 마지막 인덱스가 일치 하겠지만
 * 중복된 요소라면 서로 같은 값이 2~3개 이상 이기 때문에, 
 * 처음 인덱스와 마지막 인덱스가 일치 하지 않는다.
 */