/**
 * 진료  순서 정하기
 * 
 * 문제 설명
 * 
 * 외과의사 머쓱이는 응급실에 온 환자의 응급도를 기준으로 진료 순서를 정하려고 합니다. 
 * 정수 배열 emergency가 매개변수로 주어질 때 응급도가 높은 순서대로 
 * 진료 순서를 정한 배열을 return하도록 solution 함수를 완성해주세요.
 * 
 * 제한 사항
 * 
 * - 중복된 원소는 없습니다.
 * - 1 ≤ emergency의 길이 ≤ 10
 * - 1 ≤ emergency의 원소 ≤ 100
 * 
 * 입출력 에시
 * 
 *  emergency	                 result
 * [3, 76, 24]	               [3, 1, 2]
 * [1, 2, 3, 4, 5, 6, 7]	[7, 6, 5, 4, 3, 2, 1]
 * [30, 10, 23, 6, 100]	       [2, 4, 3, 5, 1]
 * 
 * 입출력 에시 설명
 * 
 * ex1) emergency가 [3, 76, 24]이므로 응급도의 크기 순서대로 번호를 매긴 [3, 1, 2]를 return합니다.
 * ex2) emergency가 [1, 2, 3, 4, 5, 6, 7]이므로 응급도의 크기 순서대로 번호를 매긴 [7, 6, 5, 4, 3, 2, 1]를 return합니다.
 * ex3) emergency가 [30, 10, 23, 6, 100]이므로 응급도의 크기 순서대로 번호를 매긴 [2, 4, 3, 5, 1]를 return합니다.
 * 
 */

/**
 * 문제 해석
 * 
 * 요소의 값이 큰 순서대로 번호 매기기
 * 
 * 요소의 값들을 비교하는? 
 * 
 * sort -> index numer 표시 -> 원래 순서대로 바꾸기? 
 * 
 * 순서 정리를 하던 아니면 큰값을 하던. 
 * 
 * map? -> 
 * 
 * 
 * 
 */


function solution (emergency) {
    let arr = emergency.slice().sort((a,b) => b-a);
    return emergency.map(v=>arr.indexOf(v)+1);
}

/**
 * 
 * emergency의 배열의 요소 중에서 큰 값을 가진 요소에 작은 index를 부여 해야 된다.
 * 그러기 위해서는 원본 배열이 아닌 복제된 배열이 필요하고,
 * slice 메서드를 통해 원본 배열을 유지하고 복제된 배열을 추가하는 작업을 하였다.
 * 
 * 그리고 난다음 sort 메서드를 통해 역순으로 배치하여 작은 index를 부여 하였다.
 * 
 * return 에서 emergency 배열에 map 메서드를 이용해서 요소의 인덱스를 반환해 준다.
 * map 의 callback 식으로 arr.indexOf(v)를 넣어 emergency에 있는 요소의 인덱스를 
 * arr에서 지정된 index의 값으로 출력해 준다. +1이 붙은 이유는, 순위가 제일 높은건 1,2,3
 * 이지만 배열에서 순위가 높은순은 0,1,2 가 되기 때문에 +1을 붙여 주는 것이다.
 * 
 * 그러면 제일 값이 커서 인덱스가 처음 이었던 0은 +1이 되서 1을 반환 한다. 
 */