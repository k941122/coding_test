/**
 * 배열 조각하기
 * 
 * 문제 설명
 * 
 * 정수 배열 arr와 query가 주어집니다.
 * 
 * query를 순회하면서 다음 작업을 반복합니다.
 * 
 * 짝수 인덱스에서는 arr에서 query[i]번 인덱스를 제외하고 배열의 query[i]번 인덱스 뒷부분을 잘라서 버립니다.
 * 홀수 인덱스에서는 arr에서 query[i]번 인덱스는 제외하고 배열의 query[i]번 인덱스 앞부분을 잘라서 버립니다.
 * 위 작업을 마친 후 남은 arr의 부분 배열을 return 하는 solution 함수를 완성해 주세요.
 * 
 * 제한 사항
 * 
 * - 5 ≤ arr의 길이 ≤ 100,000
 *   0 ≤ arr의 원소 ≤ 100
 * 
 * - 1 ≤ query의 길이 < min(50, arr의 길이 / 2)
 *   query의 각 원소는 0보다 크거나 같고 남아있는 arr의 길이 보다 작습니다.
 * 
 * 입출력 예시 
 * 
 *          arr	           query	result
 * [0, 1, 2, 3, 4, 5]	[4, 1, 2]	[1, 2, 3]
 * 
 * 입출력 예시 설명
 * 
 * ex1) 이번에 매번 처리할 query의 값과 처리 전후의 arr의 상태를 표로 나타내면 다음과 같습니다.
 * query의 값	query 처리 전	query 처리 후	비고
4	[0, 1, 2, 3, 4, 5]	[0, 1, 2, 3, 4]	0번 인덱스의 쿼리이므로 뒷부분을 자른다.
1	[0, 1, 2, 3, 4]	[1, 2, 3, 4]	1번 인덱스의 쿼리이므로 앞부분을 자른다.
2	[1, 2, 3, 4]	[1, 2, 3]	2번 인덱스의 쿼리이므로 뒷부분을 자른다.
 * 따라서 [1, 2, 3]을 return 합니다.
 * 
 * 
 */

/**
 * 문제 해석
 * 
 * arr 배열
 * 
 * 쿼리 배열 query
 * 
 * arr에서 특정 인덱스를 기준으로 배열의 일부를 자르기
 * 
 * 쿼리 배열의 각 원소 - arr에서 잘라낼 부분의 시작 인덱스를 나타냄
 * 
 * 마지막 인덱스 부터 시작해서 맨앞가지 빼기
 * 
 * 
 * 
 * for반복문 쿼리 길이 까지
 * 
 * 쿼리 요소 추가
 * 
 * if else 
 * 
 */

function solution(arr, query) {
    for(let i = 0 ; i < query.length ; i ++) {
        const cur = query[i]
        
        if(i%2 === 0) {
            arr.splice(cur+1, arr.length -(cur+1))
        } else {
             arr.splice(0, cur)
        }
    }
    
    return arr
}

/**
 * 쿼리 길이 만늠을 loop하는 for문 안에 
 *  const cur에 query의 요소의 값을 할당해준다.
 * 
 * if 문을 이용해 인덱스가 짝숨녀 arr배열을 splice를 이용해서 현재 할당된 cur의 값에서 +1을
 * 더한 범위와 배열의 마지막 범위 까지를 추춣하고
 * 
 * 아니면 처음부터 쿼리 요소까지 추출해준다.
 */