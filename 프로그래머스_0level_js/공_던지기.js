/**
 * 공 던지기
 * 
 * 문제 설명
 * 
 * 머쓱이는 친구들과 동그랗게 서서 공 던지기 게임을 하고 있습니다. 
 * 공은 1번부터 던지며 오른쪽으로 한 명을 건너뛰고 그다음 사람에게만 던질 수 있습니다. 
 * 친구들의 번호가 들어있는 정수 배열 numbers와 정수 K가 주어질 때, 
 * k번째로 공을 던지는 사람의 번호는 무엇인지 
 * return 하도록 solution 함수를 완성해보세요.


 * 
 * 제한 사항
 * 
 * - 2 < numbers의 길이 < 100
 * - 0 < k < 1,000
 * - numbers의 첫 번째와 마지막 번호는 실제로 바로 옆에 있습니다.
 * - numbers는 1부터 시작하며 번호는 순서대로 올라갑니다.
 * 
 * 입출력 예시 
 * 
 *   numbers	        k	result
 * [1, 2, 3, 4]	        2	3
 * [1, 2, 3, 4, 5, 6]	5	3
 * [1, 2, 3]	        3	2
 * 
 * 입출력 예시 설명
 * 
 * ex1) 1번은 첫 번째로 3번에게 공을 던집니다.
 *      3번은 두 번째로 1번에게 공을 던집니다.
 * 
 * ex2) 1번은 첫 번째로 3번에게 공을 던집니다.
 *      3번은 두 번째로 5번에게 공을 던집니다.
 *      5번은 세 번째로 1번에게 공을 던집니다.
 *      1번은 네 번째로 3번에게 공을 던집니다.
 *      3번은 다섯 번째로 5번에게 공을 던집니다.
 * 
 * ex3) 1번은 첫 번째로 3번에게 공을 던집니다.
 *      3번은 두 번째로 2번에게 공을 던집니다.
 *      2번은 세 번째로 1번에게 공을 던집니다.
 * 
 * 
 */

/**
 * 문제 해석
 * 
 * numbers 배열 
 * 
 * k 멈춰야 되는 수
 * 
 * 멈춘 수의 index를 구하시오 
 * 
 * 반복문 while 문 써야됨 
 * 
 * k-1 해야됨 던지기 때문에 해당 index를 구해야됨 
 * 
 */

function solution (numbers,k) {
    return numbers[(k-1)*2%numbers.length];
}

/**
 * k는 몇번째로 공을 던지는지 나타낸다.
 * 
 * 여기서 k-1을 하는 이유는 배열 인덱스가 0부터 시작하기 때문이다.
 * 그리고 *2는 다음 다음 사람이 하기 때문에 2를 곱해야 한다. 
 * 
 * 
 * 해당 식들을 % number.length 를 한 이유는 배열의 길이 만큼을 못넘게 하기 위해서다.
 * 
 * 만약 k-1)*2 를 계산한 값이 numbers의 길이 보다 크다면 오류가 일어난다. 
 * 이때 %(나머지 값을 계산한다.)를 이용해 number.length를 나눠준다면 
 * 나머지 값이 원하는 값이 된다!
 */